<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Retro Jump Game</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; background: #111; image-rendering: pixelated; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W, H, blockSize, columns;
const desiredColumns = 8;

let level = 1;
const gravity = 0.3;
const blockGravity = gravity / 4;
let spawnTimer = 0, spawnInterval = 100;
let gameEnded = false;

function resize() {
  const cssW = window.innerWidth;
  const cssH = window.innerHeight;
  const dpi = window.devicePixelRatio || 1;

  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = cssW * dpi;
  canvas.height = cssH * dpi;

  ctx.resetTransform();
  ctx.scale(dpi, dpi);

  W = cssW;
  H = cssH;
  blockSize = W / desiredColumns;
  columns = desiredColumns;

  player.w = blockSize / 4;
  player.h = blockSize / 4;
  player.x = (W - player.w) / 2;
  player.y = H - player.h;
}
window.addEventListener('resize', resize);

class Block {
  constructor(x) {
    this.x = x;
    this.y = -blockSize;
    this.w = blockSize;
    this.h = blockSize;
    this.vy = 0;
    this.static = false;
  }
  update() {
    if (!this.static) {
      this.vy += blockGravity;
      this.y += this.vy;
      let rest = H - this.h;
      for (let b of blocks) {
        if (b.static && b.x === this.x && this.y + this.h > b.y) rest = b.y - this.h;
      }
      if (this.y > rest) {
        this.y = rest;
        this.static = true;
        this.vy = 0;
        if (
          player.x < this.x + this.w &&
          player.x + player.w > this.x &&
          player.y < this.y + this.h &&
          player.y + player.h > this.y
        ) endGame('Game Over!');
      }
    }
  }
  draw() {
    ctx.fillStyle = '#00f';
    ctx.fillRect(this.x, this.y, this.w, this.h);
  }
}

class Player {
  constructor() {
    this.w = 20;
    this.h = 20;
    this.x = 0;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;
    this.onGround = false;
    this.acc = 0.5;
    this.accTap = 0.15;
    this.holdThreshold = 150; // ms
    this.maxSpeed = 4;
    this.friction = 0.8;
    this.left = false;
    this.right = false;
    this.leftTime = 0;
    this.rightTime = 0;
  }
  update() {
    this.vy += gravity;
    const now = performance.now();
    if (this.left) {
      const dt = now - this.leftTime;
      const a = dt < this.holdThreshold ? this.accTap : this.acc;
      this.vx -= a;
    }
    if (this.right) {
      const dt = now - this.rightTime;
      const a = dt < this.holdThreshold ? this.accTap : this.acc;
      this.vx += a;
    }

    if (!this.left && !this.right) {
      this.vx *= this.friction;
      if (Math.abs(this.vx) < 0.1) this.vx = 0;
    }

    this.vx = Math.max(-this.maxSpeed, Math.min(this.vx, this.maxSpeed));

    const oldX = this.x;
    const oldY = this.y;
    let newX = oldX + this.vx;
    let newY = oldY + this.vy;

    // horizontal collision skip feet
    for (let b of blocks) {
      if (!b.static) continue;
      if (Math.abs(oldY + this.h - b.y) < 2) continue;
      if (newY + this.h > b.y && newY < b.y + b.h) {
        if (this.vx > 0 && oldX + this.w <= b.x && newX + this.w > b.x) {
          newX = b.x - this.w;
          this.vx = 0;
        }
        if (this.vx < 0 && oldX >= b.x + b.w && newX < b.x + b.w) {
          newX = b.x + b.w;
          this.vx = 0;
        }
      }
    }
    newX = Math.max(0, Math.min(newX, W - this.w));

    let grounded = false;
    if (newY + this.h > H) {
      newY = H - this.h;
      this.vy = 0;
      grounded = true;
    }
    for (let b of blocks) {
      if (!b.static) continue;
      if (newX + this.w > b.x && newX < b.x + b.w) {
        if (this.vy > 0 && oldY + this.h <= b.y && newY + this.h > b.y) {
          newY = b.y - this.h;
          this.vy = 0;
          grounded = true;
        }
        if (this.vy < 0 && oldY >= b.y + b.h && newY < b.y + b.h) {
          newY = b.y + b.h;
          this.vy = 0;
        }
      }
    }

    this.x = newX;
    this.y = newY;
    this.onGround = grounded;

    if (this.y + this.h < 0) nextLevel();
  }
  draw() {
    ctx.fillStyle = '#f00';
    ctx.fillRect(this.x, this.y, this.w, this.h);
  }
  jump() {
    if (this.onGround) {
      this.vy = -Math.sqrt(2 * gravity * blockSize * 2.2);
      this.onGround = false;
    }
  }
}

const blocks = [];
const player = new Player();
spawnBlock();
function spawnBlock() {
  const col = Math.floor(Math.random() * columns);
  blocks.push(new Block(col * blockSize));
}
function nextLevel() {
  level++;
  blocks.length = 0;
  spawnTimer = 0;
  player.x = (W - player.w) / 2;
  player.y = H - player.h;
  player.vx = 0;
  player.vy = 0;
}
function update() {
  if (gameEnded) return;
  spawnTimer++;
  if (spawnTimer > spawnInterval) {
    spawnTimer = 0;
    spawnBlock();
  }
  blocks.forEach(b => b.update());
  player.update();
}
function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#fff';
  ctx.font = '20px monospace';
  ctx.fillText('Level: ' + level, 10, 30);
  blocks.forEach(b => b.draw());
  player.draw();
}
function loop() {
  update();
  draw();
  if (!gameEnded) requestAnimationFrame(loop);
}
function endGame(msg) {
  gameEnded = true;
  setTimeout(() => { alert(msg); window.location.reload(); }, 10);
}
window.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') {
    if (!player.left) player.leftTime = performance.now();
    player.left = true;
  }
  if (e.key === 'ArrowRight' || e.key === 'd') {
    if (!player.right) player.rightTime = performance.now();
    player.right = true;
  }
  if ([' ', 'ArrowUp', 'w'].includes(e.key)) player.jump();
});
window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') player.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd') player.right = false;
});
canvas.addEventListener('touchstart', () => player.jump());
window.addEventListener('deviceorientation', e => {
  player.vx = ((e.gamma || 0) / 45) * player.maxSpeed;
});
resize();
loop();
</script>
</body>
</html>
